<!DOCTYPE html>
<html lang="en">

<title>PS70: Intro to Digital Fabrication </title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="./style.css" rel="stylesheet">
  <!--top of nav bar-->

<nav class="navbar navbar-expand-sm navbar-light bg-light">
  <div style="align-items: left; justify-content:left;" class="container-fluid">
    <h3 class="nav-title"> PS70: Intro to Digital Fabrication</h3>
    <div class="navbar-nav">
      <h4><a class="nav-link" href="./index.html">Home</a></h4>
      <h4><a class="nav-link" href="./about.html">About</a></h4>
      <h4><a class="nav-link" href="../finalproject.html">Final Project</a></h4>
    </div>
  </div>
</nav>

<body>
<!--navigation bar at top of page--> 


<xmp style="display:none;">
<!--everything in page body following css style page in downloads folder-->

### Final Project Proposal for 09/6

Eileen is a film student, and something she would like to explore in her final project is an effective audio-adjusting microphone. Essentially, it would record everything in the most optimal range for video editing. Generally, you do this by asking someone to speak loudly and adjusting the gain down on a knob or by pressing a button on a recording device until that persons' voice does not "clip". This means your gain (or sensitivity basically explained here:
[https://mynewmicrophone.com/microphone-gain/](https://mynewmicrophone.com/microphone-gain/) [https://www.makeuseof.com/what-is-microphone-gain-how-does-it-affect-recording-volume/](https://www.makeuseof.com/what-is-microphone-gain-how-does-it-affect-recording-volume/)) is as high as it can be so you are recieving the most amount of information to give you the most flexibility when editing. But what if there was an auto-adjusting microphone that tried to keep your speakers' voice in the right range without peaking? The complaint about programs that do this (in some computers, for example [https://www.partitionwizard.com/partitionmanager/how-to-stop-microphone-auto-adjusting-win10.html](https://www.partitionwizard.com/partitionmanager/how-to-stop-microphone-auto-adjusting-win10.html)) is that it might change as you are speaking and you lose variability in what that person says and their tone of voice. You may also have peaking (sound too loud to be propperly recorded) before the microphone adjusts or the microphone flattening or leveling the sound. I wonder if by using two microphones, one that adjusts and one that doesn't, and put them in the same microphone cage recording into two channels—the editor would be able to get the information and consistency they need to edit sound well and record it efficiently. One microphone would wait to record while sensing a good, safe gain to set, while the other would start sensing when the sound is "peaking" or not being recorded and begin auto adjusting.
<br>
I would fabricate the molds for the microphone cage that holds both recievers and the recieving/recording device as well as the sound recieving technology, which I assume will be somewhat like using the vinyl printer to make a speaker. The input will be the sound and output will be the way it records and stores the sound through a reciever. The microcontroller will control, at the very least, how the gain adjusts in response to what the reciever records.

<h3>Final Project Proposal for Ibrahim Section</h3>

INSPIRATION

I am a student in the AFVS department studying film. I get frustrated a lot by sound. It is a lot harder to work with (for me) than visuals are. Visuals are easier to track and a bit more predictable (ie, someone will give me the visual cue of bending down before they jump). But with sound? A subject could suddenly get super excited and start yelling in the middle of an interview, and all the sound cuts out. To cure this, you could use an Automatic Gain Control system atached to the mic to help this. They have these in some programs on your computer for video chatting, like Zoom. According to some cursory internet sources, like [Major Geeks .com](https://www.majorgeeks.com/content/page/what_is_microphone_agc_and_should_it_be_on_or_off.html) AGC is not reccomended for audio capture because "it isn't "smart." The problem is that AGC can't predict noises and adjusts on the fly, often too late. One of the few situations where this might not matter is anyone using their microphone for video conferencing, remote tech support, etc. Those who are recording for quality will want to turn AGC off." In my project, I would put two microphone receptors in the body of the device, one recording at a higher level and one at a lower gain to minimize the effect of the adjustment of the gain being late.

STORY

When recording an interview with my great-aunt recently, I asked her to say a few words, set my microphone gain (or sensitivity) accordingly, and begain asking her questions. It was just me there shooting, and as she got more excited and started saying more interesting things, she got louder. And louder. By the time I finished the interview she was too loud, and the audio I picked up was clipping too much to be usable. An automatic gain adjusting microphone with a backup adjusting microphone set to a lower gain would prevent this problem in the future.

OPPORTUNITY/PROBLEM

I want to build a "smart"ish automatic gain control microphone to capture audio for videomaking projects because right now the technology does not adjust to the voice of the subject. The technology to do so right now does not account for the time it takes the microphone to register that the volume it is perceiving has changed and modulate its gain.

RESEARCH/REFERENCES

[This document outlines a pathway for a program that would auto-adjust the microphone gain from Texas Instruments](https://www.ti.com/lit/an/snaa028a/snaa028a.pdf)

[This is a video about where to find microphone parts and how to design and solder a basic microphone that has two receptors inside](https://www.youtube.com/watch?v=FjMp1RezqFI)

[This website outlines various kinds of microphone receptor constructions](https://bothners.co.za/dynamic-vs-condenser-mics-a-basic-introduction/#:~:text=Condenser%20mics%20are%20constructed%20with,also%20need%20a%20power%20source)

[This is just a Wikipedia page on AGC microphone uses](https://en.wikipedia.org/wiki/Automatic_gain_control#:~:text=The%20AGC%20circuit%20keeps%20the,level%20within%20an%20acceptable%20range)

<h3>FOR CLASS 9/27 FINAL PROJECT UPDATE</h3>

Bill of Materials (we may have some of these, so I have not looked up specifics on prices yet):

Audio cable
4-5 microphone receptors (because I am not good at soldering)
3D printing materials
A cat toy/foam/some fabric I can use as a wind screen
Heat Shrink
Solder
Microcontroller
Duck (or Duct) Tape


Project Timeline:

9/27 Ask if makerspace has microphone receptors and an audio cable I can cut open

10/2 Print a microphone body based on size of microphones

10/7 Solder and put together microphone physically, so it works as a non AGC microphone

10/14 Attempt to program Microcontroller to work roughly like the Texas Instruments model and attach it to a microphone. 

10/15 Ask for help:)

10/21 Test microphone make plans for other designs

10/28 Fixes, one that is more receptive

11/4 Design your own condenser microphone receptor

11/11 Fixes; can you get it to work in a zoom?

11/18 Fixes; can you make your own basic zoom for it/way for it to record on an SD card?

11/25 Fixes


Project Plan:

I will need to 3D print a cage/body for my microphone like one of the ones in the reference video in the previous section (min 46:51) as well as a little box for my microchip AGC regulator circuit to live in.

I will put the microphones inside the 3D printed body, either loosely or with some glue to help with noise cancelling. Then I will attach it to a cut audio cable using duck tape (like he does in my reference video), so I can snatch the adapter off of that. I will test the microphone on an existing zoom. Once I see it works, I will program the microcrontroller to work like the circuit of systems in the Texas Instruments pdf, and get help completely understanding it. I will attach the AGC microcontroller system to the microphone with tape then attach the full system to the audio cable then connect that to the existing zoom. I will then solder and heatshink the connections—if the contraption works to modulate gain effectively. I will then test to see the optimal amount that the second microphone should be set lower than the first microphone, and link them somehow, so that they always follow one below the other both as AGC mics with different gain thresholds. Or maybe they will run separately, but they will be set to the same threshold to change their gain, but their starting gains are differnt.


<h3>Final Project Week of 11/14 Update:</h3>

I changed my design to be a rotating microphone that you can put in the center of a table during meetings and the microphone can sense when someone is talking and move to better pick up that person's voice.

My first design for this was going to be built using ultrasonic sensors. My plan was for the motor to have a platform that rotates with microphones on it. There would be one ultrasonic sensor that has the main microphone placed on top of it (this will eventually by an additional microphone that is of better quality than the others and connects to the camera). The logic would go as follows: That if a mic sensed a louder sound than the other microphones, the motor would turn the setup in that direction until the sensor detected something close to it. 

<img src="./fpMVPoriginaldesign.JPEG" alt="original ultrasonic sensor" width="250" height="300">

The problem with that design would be if three people are talking. Let's say they are sitting in a line in this order: Person 1, Person 2, Person 3. If Person 1 is talking and Person 3 responds, the motor will start to move, but stop at Person 2 because they would be close to it, and the code says the motor should run until the sensor detects something close to it.

Here is the sheet where I worked this problem out with Ibrahim's help:

 <img src="./fpMVPredesignwibrahim.JPEG" alt="page of brainstorming" width="250" height="300">

<h5>MVP Design Code</h5>


My change to the design was that I had 3 set positions that do not change. Each position has a microphone that sits beneath the rotating platform so that they do not move. I numbered the positions 1, 2, and 3 and the mics in those positions 1, 2, and 3 accordingly in the code. Each is evenly placed around the motor 120 degrees apart. 

 <img src="./fpMVPmeasuringmics.JPEG" alt="measuring mics" width="250" height="300">

I put a paper cone around each one to focus the area they were sensing, and to physically label them. 

 <img src="./fpMVPmakingcones.JPEG" alt="paper cones" width="250" height="300">

In the code, the idea was to make an if statement for every situation the mics would be in. For example, that if the platform is at position 1 and mic3's sound crosses a threshold, the steppermotor should take 120 degrees of steps in the direction of mic 3, then set its position to 3. 

To roughtly calibrate the MVP, the platform has an arrow on it and you move the platform so that the arrow points at microphone 1.

 <img src="./fpMVPplatformarrow.JPEG" alt="platform" width="250" height="300">

Here is my code:

<div style="height: 350px; overflow: scroll">
<pre><code class="language-arduino">
class Microphone

 {
 const int sampleWindow = 50; // Sample window width in mS (50 mS = 20Hz)
 unsigned int sample;

 int Microphonepin;

 unsigned long startMillis= millis();  // Start of sample window
    unsigned int peakToPeak = 0;   // peak-to-peak level

    unsigned int signalMax = 0;
    unsigned int signalMin = 1024;

   public: 

   Microphone(int pin)
{
   Microphonepin = pin;
   
}

int GetSoundLevel()
{ 
  startMillis=millis();

  signalMax = 0;

  signalMin = 1024;
  
  while ((millis() - startMillis) < sampleWindow)
  {
       sample = analogRead(Microphonepin);   //reading DC pin from pin A0
       if (sample < 1024)  // toss out spurious readings
       {
          if (sample > signalMax)
          {
             signalMax = sample;  // save just the max levels
          }
          else if (sample < signalMin)
          {
             signalMin = sample;  // save just the min levels
          }
       }
   }
    peakToPeak = signalMax - signalMin;

    return peakToPeak;
}
    
 };

Microphone mic1(0);
Microphone mic2(1);
Microphone mic3(2);

//motor stuff
int A1A = 9;
int A1B = 6;
int B1A = 11;
int B1B = 10;

int Pa;
int Pb;

uint16_t stepnumber = 0;

 void setup() 
 {
    Serial.begin(9600);

    // motor stuff
  pinMode(A1A, OUTPUT);
  pinMode(A1B, OUTPUT);
  pinMode(B1A, OUTPUT);
  pinMode(B1B, OUTPUT);
 }

 void take_step(int stepnumber, int MAXpower, int wait) {
  Pa = (sin(stepnumber * 0.098174) * MAXpower);
  Pb = (cos(stepnumber * 0.098174) * MAXpower);

  if (Pa>0) {
    analogWrite(A1A,Pa);
    analogWrite(A1B,0);
  } else{
    analogWrite(A1A,0);
    analogWrite(A1B,abs(Pa));
  }

  if (Pb>0) {
    analogWrite(B1A,Pb);
    analogWrite(B1B,0);
  } else{
    analogWrite(B1A,0);
    analogWrite(B1B,abs(Pb));
  }

  delayMicroseconds(wait);
}

void hold(int wait){     // apply max holding torque 
  analogWrite(A1A, 255);
  analogWrite(A1B, 0);
  analogWrite(B1A, 255);
  analogWrite(B1B, 0);
  delay(wait);
}

int long placement = 1;
 void loop() 
 {

    Serial.print(mic1.GetSoundLevel());
    Serial.print(",");
    Serial.print(mic2.GetSoundLevel());
    Serial.print(",");
    Serial.print(mic3.GetSoundLevel());
    Serial.println();
// motor stuff



if ((placement == 1) && (mic2.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i++){
    stepnumber++;
    take_step(stepnumber, 255, 1000);

  }
  hold(500);
  placement = 2;
}

if ((placement == 2) && (mic1.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i--){
    stepnumber--;
    take_step(stepnumber, 255, 1000);
  }
  hold(500);
  placement = 1;
  
}

if ((placement == 2) && (mic3.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i++){
    stepnumber++;
    take_step(stepnumber, 255, 1000);
  }
  hold(500);
  placement = 3;
}

if ((placement == 3) && (mic2.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i--){
    stepnumber--;
    take_step(stepnumber, 255, 1000);

  }
  hold(500);
  placement = 2;
}

if ((placement == 3) && (mic1.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i++){
    stepnumber++;
    take_step(stepnumber, 255, 1000);

  }
  hold(500);
  placement = 1;
}

if ((placement == 1) && (mic3.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i--){
    stepnumber--;
    take_step(stepnumber, 255, 1000);
  }
  hold(500);
  placement = 3;
}
   }
 </code></pre>
  </div>

This did not work as well as I intended. When you knock on the table next to one of the mics, the arrow does move to another position. But not necessarily the position you knocked on. It also doesn't always respond to the knocking, and you have to try several times. After the second knock, the motor just spins forever.


<h5>MVP Physical Design</h5>

I initially thought I could get out of soldering by just wrapping wire into each of the microphone ports. But I ended up with bad connection and not using each port which ended up with a lot of things overheating and wires crossing. 

<img src="./fpMVPredoingmics.JPEG" alt="redoing the mics" width="250" height="300">

So I soldered wires to each of the microphones and attached them to the microcontroller like they do on the website here: <a href="https://nathanmelenbrink.github.io/ps70/06_input/index.html">Class Website Microphone Setup</a> This involved a lot of messy wires I will have to consolidate when I make my final version of the project, especially after I added in the stepper motor and driver. 

<img src="./fpMVPmics1and2.JPEG" alt="mics 1 and 2 in final design" width="250" height="300">


I attached the 4 microcontroller wires in order into the ports on the L9110 motor driver. I plugged them into the pwm ports on my board (from A1A to B1B ) 9,6,11, and 10. The motor driver/stepper motor and the microphones all ran off of one microcontroller running off of power from my computer. I attached the ground and Vin pins from my Arduino Uno board to a breadboard and attached the Vin/ground pins for the other elements to this breadboard.

 <img src="./fpMVPfinalwithwiring.JPEG" alt="final wiring" width="250" height="300">

<h5> MVP Test</h5>

<img src="./fpMVPoverheadfinal.JPEG" alt="birds-eye view of final design" width="250" height="300">


Here is the video <a href="https://www.youtube.com/shorts/I_LSmOynZu8">And here is a link to it on Youtube</a> 


<iframe src="https://www.youtube.com/shorts/I_LSmOynZu8" style="border:none;" title="MVP Test"></iframe>



<h5> Next Step Ideas </h5>

In my next iteration of the project, I would like to put a magnet on the part of the platform where the microphone will be, this will allow me to make it so the device auto calibrates. My plan is to put a Hall sensor next to the position 1 microphone and have the setup code to be that the motor needs to rotate until the position 1 sensor reads the right magnetic field. To do this, I would measure what the magnetic sensor reads when the platform is facing position 1. 

I would also like to add the more sensitive new microphones the lab has to my design. I will add different logic to the code, and have the motor run by a separate power source. I was having trouble getting the stepper motor to turn in both directions and I wonder if that is part of my problem here still. I will fix logic of the code so that the motor never turns all the way around, because that would tangle the wires of the shotgun mic that sits on top of the device and attaches to the camera. 

If that all works, I will also add a feature with the more sensitive microphones where they calibrate that the "room tone" is 0 and that if, say someone is standing between mic 1 and 2 the microphone will turn the correct amount to match where that person is standing. This means that I will have to do some different type of coding the logic than I had for the previous version, where I just listed out all the possibilities.

My goal is to also 3D print everything into a little cylinder with a compartment on the bottom for the microcontroller and motor driver, a space above that for the motor to sit in, and little pockets evenly spaced apart for the microphones to sit in. The top platform will be more of a rail in this design that the main microphone can slide onto and the bottom of the device will have a 3D printed design of the attachment piece that the main microphone has now, so the whole thing can fit on a camera.











</xmp>
</body>

<script src="./strapdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" ></script>

</html>