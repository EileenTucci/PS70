<!DOCTYPE html>
<html lang="en">

<title>PS70: Intro to Digital Fabrication </title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="./style.css" rel="stylesheet">
  <!--top of nav bar-->

<nav class="navbar navbar-expand-sm navbar-light bg-light">
  <div style="align-items: left; justify-content:left;" class="container-fluid">
    <h3 class="nav-title"> PS70: Intro to Digital Fabrication</h3>
    <div class="navbar-nav">
      <h4><a class="nav-link" href="./index.html">Home</a></h4>
      <h4><a class="nav-link" href="./about.html">About</a></h4>
      <h4><a class="nav-link" href="../finalproject.html">Final Project</a></h4>
    </div>
  </div>
</nav>

<body>
<!--navigation bar at top of page--> 


<xmp style="display:none;">
<!--everything in page body following css style page in downloads folder-->

### Final Project Proposal for 09/6

Eileen is a film student, and something she would like to explore in her final project is an effective audio-adjusting microphone. Essentially, it would record everything in the most optimal range for video editing. Generally, you do this by asking someone to speak loudly and adjusting the gain down on a knob or by pressing a button on a recording device until that persons' voice does not "clip". This means your gain (or sensitivity basically explained here:
[https://mynewmicrophone.com/microphone-gain/](https://mynewmicrophone.com/microphone-gain/) [https://www.makeuseof.com/what-is-microphone-gain-how-does-it-affect-recording-volume/](https://www.makeuseof.com/what-is-microphone-gain-how-does-it-affect-recording-volume/)) is as high as it can be so you are recieving the most amount of information to give you the most flexibility when editing. But what if there was an auto-adjusting microphone that tried to keep your speakers' voice in the right range without peaking? The complaint about programs that do this (in some computers, for example [https://www.partitionwizard.com/partitionmanager/how-to-stop-microphone-auto-adjusting-win10.html](https://www.partitionwizard.com/partitionmanager/how-to-stop-microphone-auto-adjusting-win10.html)) is that it might change as you are speaking and you lose variability in what that person says and their tone of voice. You may also have peaking (sound too loud to be propperly recorded) before the microphone adjusts or the microphone flattening or leveling the sound. I wonder if by using two microphones, one that adjusts and one that doesn't, and put them in the same microphone cage recording into two channels—the editor would be able to get the information and consistency they need to edit sound well and record it efficiently. One microphone would wait to record while sensing a good, safe gain to set, while the other would start sensing when the sound is "peaking" or not being recorded and begin auto adjusting.
<br>
I would fabricate the molds for the microphone cage that holds both recievers and the recieving/recording device as well as the sound recieving technology, which I assume will be somewhat like using the vinyl printer to make a speaker. The input will be the sound and output will be the way it records and stores the sound through a reciever. The microcontroller will control, at the very least, how the gain adjusts in response to what the reciever records.

<h3>Final Project Proposal for Ibrahim Section</h3>

INSPIRATION

I am a student in the AFVS department studying film. I get frustrated a lot by sound. It is a lot harder to work with (for me) than visuals are. Visuals are easier to track and a bit more predictable (ie, someone will give me the visual cue of bending down before they jump). But with sound? A subject could suddenly get super excited and start yelling in the middle of an interview, and all the sound cuts out. To cure this, you could use an Automatic Gain Control system atached to the mic to help this. They have these in some programs on your computer for video chatting, like Zoom. According to some cursory internet sources, like [Major Geeks .com](https://www.majorgeeks.com/content/page/what_is_microphone_agc_and_should_it_be_on_or_off.html) AGC is not reccomended for audio capture because "it isn't "smart." The problem is that AGC can't predict noises and adjusts on the fly, often too late. One of the few situations where this might not matter is anyone using their microphone for video conferencing, remote tech support, etc. Those who are recording for quality will want to turn AGC off." In my project, I would put two microphone receptors in the body of the device, one recording at a higher level and one at a lower gain to minimize the effect of the adjustment of the gain being late.

STORY

When recording an interview with my great-aunt recently, I asked her to say a few words, set my microphone gain (or sensitivity) accordingly, and begain asking her questions. It was just me there shooting, and as she got more excited and started saying more interesting things, she got louder. And louder. By the time I finished the interview she was too loud, and the audio I picked up was clipping too much to be usable. An automatic gain adjusting microphone with a backup adjusting microphone set to a lower gain would prevent this problem in the future.

OPPORTUNITY/PROBLEM

I want to build a "smart"ish automatic gain control microphone to capture audio for videomaking projects because right now the technology does not adjust to the voice of the subject. The technology to do so right now does not account for the time it takes the microphone to register that the volume it is perceiving has changed and modulate its gain.

RESEARCH/REFERENCES

[This document outlines a pathway for a program that would auto-adjust the microphone gain from Texas Instruments](https://www.ti.com/lit/an/snaa028a/snaa028a.pdf)

[This is a video about where to find microphone parts and how to design and solder a basic microphone that has two receptors inside](https://www.youtube.com/watch?v=FjMp1RezqFI)

[This website outlines various kinds of microphone receptor constructions](https://bothners.co.za/dynamic-vs-condenser-mics-a-basic-introduction/#:~:text=Condenser%20mics%20are%20constructed%20with,also%20need%20a%20power%20source)

[This is just a Wikipedia page on AGC microphone uses](https://en.wikipedia.org/wiki/Automatic_gain_control#:~:text=The%20AGC%20circuit%20keeps%20the,level%20within%20an%20acceptable%20range)

<h3>FOR CLASS 9/27 FINAL PROJECT UPDATE</h3>

Bill of Materials (we may have some of these, so I have not looked up specifics on prices yet):

Audio cable
4-5 microphone receptors (because I am not good at soldering)
3D printing materials
A cat toy/foam/some fabric I can use as a wind screen
Heat Shrink
Solder
Microcontroller
Duck (or Duct) Tape


Project Timeline:

9/27 Ask if makerspace has microphone receptors and an audio cable I can cut open

10/2 Print a microphone body based on size of microphones

10/7 Solder and put together microphone physically, so it works as a non AGC microphone

10/14 Attempt to program Microcontroller to work roughly like the Texas Instruments model and attach it to a microphone. 

10/15 Ask for help:)

10/21 Test microphone make plans for other designs

10/28 Fixes, one that is more receptive

11/4 Design your own condenser microphone receptor

11/11 Fixes; can you get it to work in a zoom?

11/18 Fixes; can you make your own basic zoom for it/way for it to record on an SD card?

11/25 Fixes


Project Plan:

I will need to 3D print a cage/body for my microphone like one of the ones in the reference video in the previous section (min 46:51) as well as a little box for my microchip AGC regulator circuit to live in.

I will put the microphones inside the 3D printed body, either loosely or with some glue to help with noise cancelling. Then I will attach it to a cut audio cable using duck tape (like he does in my reference video), so I can snatch the adapter off of that. I will test the microphone on an existing zoom. Once I see it works, I will program the microcrontroller to work like the circuit of systems in the Texas Instruments pdf, and get help completely understanding it. I will attach the AGC microcontroller system to the microphone with tape then attach the full system to the audio cable then connect that to the existing zoom. I will then solder and heatshink the connections—if the contraption works to modulate gain effectively. I will then test to see the optimal amount that the second microphone should be set lower than the first microphone, and link them somehow, so that they always follow one below the other both as AGC mics with different gain thresholds. Or maybe they will run separately, but they will be set to the same threshold to change their gain, but their starting gains are differnt.


<h3>Final Project Week of 11/14 Update:</h3>

I changed my design to be a rotating microphone that you can put in the center of a table during meetings and the microphone can sense when someone is talking and move to better pick up that person's voice.

My first design for this was going to be built using ultrasonic sensors. My plan was for the motor to have a platform that rotates with microphones on it. There would be one ultrasonic sensor that has the main microphone placed on top of it (this will eventually by an additional microphone that is of better quality than the others and connects to the camera). The logic would go as follows: That if a mic sensed a louder sound than the other microphones, the motor would turn the setup in that direction until the sensor detected something close to it. 

<img src="./fpMVPplan.JPEG" alt="original plan" width="250" height="300">

<img src="./fpMVPoriginaldesign.JPEG" alt="original ultrasonic sensor" width="250" height="300">

The problem with that design would be if three people are talking. Let's say they are sitting in a line in this order: Person 1, Person 2, Person 3. If Person 1 is talking and Person 3 responds, the motor will start to move, but stop at Person 2 because they would be close to it, and the code says the motor should run until the sensor detects something close to it.

Here is the sheet where I worked this problem out with Ibrahim's help:

 <img src="./fpMVPredesignwibrahim.JPEG" alt="page of brainstorming" width="250" height="300">

<h5>MVP Design Code</h5>


My change to the design was that I had 3 set positions that do not change. Each position has a microphone that sits beneath the rotating platform so that they do not move. I numbered the positions 1, 2, and 3 and the mics in those positions 1, 2, and 3 accordingly in the code. Each is evenly placed around the motor 120 degrees apart. 

 <img src="./fpMVPmeasuringmics.JPEG" alt="measuring mics" width="250" height="300">

I put a paper cone around each one to focus the area they were sensing, and to physically label them. 

 <img src="./fpMVPmakingcones.JPEG" alt="paper cones" width="250" height="300">

In the code, the idea was to make an if statement for every situation the mics would be in. For example, that if the platform is at position 1 and mic3's sound crosses a threshold, the steppermotor should take 120 degrees of steps in the direction of mic 3, then set its position to 3. 

To roughtly calibrate the MVP, the platform has an arrow on it and you move the platform so that the arrow points at microphone 1.

 <img src="./fpMVPplatformarrow.JPEG" alt="platform" width="250" height="300">

Here is my code:

<div style="height: 350px; overflow: scroll">
<pre><code class="language-arduino">
class Microphone

 {
 const int sampleWindow = 50; // Sample window width in mS (50 mS = 20Hz)
 unsigned int sample;

 int Microphonepin;

 unsigned long startMillis= millis();  // Start of sample window
    unsigned int peakToPeak = 0;   // peak-to-peak level

    unsigned int signalMax = 0;
    unsigned int signalMin = 1024;

   public: 

   Microphone(int pin)
{
   Microphonepin = pin;
   
}

int GetSoundLevel()
{ 
  startMillis=millis();

  signalMax = 0;

  signalMin = 1024;
  
  while ((millis() - startMillis) < sampleWindow)
  {
       sample = analogRead(Microphonepin);   //reading DC pin from pin A0
       if (sample < 1024)  // toss out spurious readings
       {
          if (sample > signalMax)
          {
             signalMax = sample;  // save just the max levels
          }
          else if (sample < signalMin)
          {
             signalMin = sample;  // save just the min levels
          }
       }
   }
    peakToPeak = signalMax - signalMin;

    return peakToPeak;
}
    
 };

Microphone mic1(0);
Microphone mic2(1);
Microphone mic3(2);

//motor stuff
int A1A = 9;
int A1B = 6;
int B1A = 11;
int B1B = 10;

int Pa;
int Pb;

uint16_t stepnumber = 0;

 void setup() 
 {
    Serial.begin(9600);

    // motor stuff
  pinMode(A1A, OUTPUT);
  pinMode(A1B, OUTPUT);
  pinMode(B1A, OUTPUT);
  pinMode(B1B, OUTPUT);
 }

 void take_step(int stepnumber, int MAXpower, int wait) {
  Pa = (sin(stepnumber * 0.098174) * MAXpower);
  Pb = (cos(stepnumber * 0.098174) * MAXpower);

  if (Pa>0) {
    analogWrite(A1A,Pa);
    analogWrite(A1B,0);
  } else{
    analogWrite(A1A,0);
    analogWrite(A1B,abs(Pa));
  }

  if (Pb>0) {
    analogWrite(B1A,Pb);
    analogWrite(B1B,0);
  } else{
    analogWrite(B1A,0);
    analogWrite(B1B,abs(Pb));
  }

  delayMicroseconds(wait);
}

void hold(int wait){     // apply max holding torque 
  analogWrite(A1A, 255);
  analogWrite(A1B, 0);
  analogWrite(B1A, 255);
  analogWrite(B1B, 0);
  delay(wait);
}

int long placement = 1;
 void loop() 
 {

    Serial.print(mic1.GetSoundLevel());
    Serial.print(",");
    Serial.print(mic2.GetSoundLevel());
    Serial.print(",");
    Serial.print(mic3.GetSoundLevel());
    Serial.println();
// motor stuff



if ((placement == 1) && (mic2.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i++){
    stepnumber++;
    take_step(stepnumber, 255, 1000);

  }
  hold(500);
  placement = 2;
}

if ((placement == 2) && (mic1.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i--){
    stepnumber--;
    take_step(stepnumber, 255, 1000);
  }
  hold(500);
  placement = 1;
  
}

if ((placement == 2) && (mic3.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i++){
    stepnumber++;
    take_step(stepnumber, 255, 1000);
  }
  hold(500);
  placement = 3;
}

if ((placement == 3) && (mic2.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i--){
    stepnumber--;
    take_step(stepnumber, 255, 1000);

  }
  hold(500);
  placement = 2;
}

if ((placement == 3) && (mic1.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i++){
    stepnumber++;
    take_step(stepnumber, 255, 1000);

  }
  hold(500);
  placement = 1;
}

if ((placement == 1) && (mic3.GetSoundLevel() > 17))
{
   for (int i = 1; i < 1067; i--){
    stepnumber--;
    take_step(stepnumber, 255, 1000);
  }
  hold(500);
  placement = 3;
}
   }
 </code></pre>
  </div>

This did not work as well as I intended. When you knock on the table next to one of the mics, the arrow does move to another position. But not necessarily the position you knocked on. It also doesn't always respond to the knocking, and you have to try several times. After the second knock, the motor just spins forever.


<h5>MVP Physical Design</h5>

I initially thought I could get out of soldering by just wrapping wire into each of the microphone ports. But I ended up with bad connection and not using each port which ended up with a lot of things overheating and wires crossing. 

<img src="./fpMVPredoingmics.JPEG" alt="redoing the mics" width="250" height="300">

So I soldered wires to each of the microphones and attached them to the microcontroller like they do on the website here: <a href="https://nathanmelenbrink.github.io/ps70/06_input/index.html">Class Website Microphone Setup</a> This involved a lot of messy wires I will have to consolidate when I make my final version of the project, especially after I added in the stepper motor and driver. 

<img src="./fpMVPmics1and2.JPEG" alt="mics 1 and 2 in final design" width="250" height="300">


I attached the 4 microcontroller wires in order into the ports on the L9110 motor driver. I plugged them into the pwm ports on my board (from A1A to B1B ) 9,6,11, and 10. The motor driver/stepper motor and the microphones all ran off of one microcontroller running off of power from my computer. I attached the ground and Vin pins from my Arduino Uno board to a breadboard and attached the Vin/ground pins for the other elements to this breadboard.

 <img src="./fpMVPfinalwithwiring.JPEG" alt="final wiring" width="250" height="300">

<h5> MVP Test</h5>

<img src="./fpMVPoverheadfinal.JPEG" alt="birds-eye view of final design" width="250" height="300">


Here is the video <a href="https://www.youtube.com/shorts/I_LSmOynZu8">And here is a link to it on Youtube</a> 


<iframe src="https://www.youtube.com/shorts/I_LSmOynZu8" style="border:none;" title="MVP Test"></iframe>



<h5> Next Step Ideas </h5>

In my next iteration of the project, I would like to put a magnet on the part of the platform where the microphone will be, this will allow me to make it so the device auto calibrates. My plan is to put a Hall sensor next to the position 1 microphone and have the setup code to be that the motor needs to rotate until the position 1 sensor reads the right magnetic field. To do this, I would measure what the magnetic sensor reads when the platform is facing position 1. 

I would also like to add the more sensitive new microphones the lab has to my design. I will add different logic to the code, and have the motor run by a separate power source. I was having trouble getting the stepper motor to turn in both directions and I wonder if that is part of my problem here still. I will fix logic of the code so that the motor never turns all the way around, because that would tangle the wires of the shotgun mic that sits on top of the device and attaches to the camera. 

If that all works, I will also add a feature with the more sensitive microphones where they calibrate that the "room tone" is 0 and that if, say someone is standing between mic 1 and 2 the microphone will turn the correct amount to match where that person is standing. This means that I will have to do some different type of coding the logic than I had for the previous version, where I just listed out all the possibilities.

My goal is to also 3D print everything into a little cylinder with a compartment on the bottom for the microcontroller and motor driver, a space above that for the motor to sit in, and little pockets evenly spaced apart for the microphones to sit in. The top platform will be more of a rail in this design that the main microphone can slide onto and the bottom of the device will have a 3D printed design of the attachment piece that the main microphone has now, so the whole thing can fit on a camera.


This is the messy version of some of the documentation based on the notes I was writing to myself as I worked on this project, kind of more of a loose diary version


For the 3D print, I was nervous about how a 3D print with some moving parts would work. What is the order that you print everything in? Do you print it together and then take out the supports so it can turn? In the end, this was not an issue. At the beginning of revising the code after the MVP I was thinking I would maybe use gears, but I did not. 
At the time, here I watched this video for advice:
https://www.youtube.com/watch?v=ki4FqiUxBRA
Takeaway: Make the things separately and then sand them down

When I was coming up with my 3D printed design I needed to decide what type of structure it would have to have to house the main microphone, the sensor microphones, microcontroller, and the motor.

In the 3D design I would need:

Something for the motor to turn
Whatever the motor turns needs to match up to the clip onto the bottom of the main microphone so the main microphone can slide on and attach to my device;
This would have to have a direct connection to the motor, so the motor can turn it. 
It should have a magnet on it so I can use the Hall sensor to zero the machine at a given point (this was before I switched to limit switches) 
But how would I make sure the magnet doesn’t interfere with the camera?
Possible solution: Just, like just under where the magnet will be there should be sensors that are placed where the mics are placed, so it is as far away from the screens on the camera as possible.

Track on mic:
Replicate the track that is on the mic at the bottom of the device, so the device can fit into a camera like the mic does normally.
(This never ended up being done) 
I would also make the track a negative of the track on the main microphone so it can slide on and stay there.

___________________________

I figured I would make the design in 3 parts so that the motor and board could sit on too of each other. I watched this tutorial on how to make your 3D printed materials “snap-fit” what I ended up doing was making the top of the body a little bit smaller than the bottom body, and making the bottom body’s walls thinner at the top so that it makes a little shelf for the top body to sit in. 

Make snap-fit designs tutorial 
https://www.youtube.com/watch?v=dahn-9FePeM
_____________________

Initially I started thinking that to zero the device, the motor would turn 180 deg to the left and then, if the sensor does not record the magnet’s presence 360 deg to the right. This would also mean that the motor does not turn around all the way and tangle itself in the main microphone cord

If it senses the magnet, stop, set position 0. —> The question is, do I have to do this? It would involve storing position
Then also I could have the microphones calibrate to zero
I would need to store position and where the position of the motor is

You will need to calibrate these microphones before you use them! It it reads  >5 go there, if two of them are loud go to the in between place between those two microphones (this is from when I was going to use 3 microphones)


Setup code is like (i think i can just use the seconds function bc that is running the whole time and i want this to start at zero?) to wait, then wherever the microphone is is zero position.

________________

Okok— using the magnet sensor

Have check the magnet sensor, go left, if mag field decreases go right until it is the correct mag field for that position. There are 6 positions.

Make a function called “Go-To” where the motor does this

Takes 10 steps (for ex), reads then decides to go in the other direction until hall sensor reads xxx
Position u want to go to, if all the positions are predefined.

This did not work because hall sensors only read what is directly above them.
_____________________________

Put separate power supply for motor and for board! Maybe this will make the motor run better
______________________________

I looked up the analog pins for ESP32 to use the hall sensor, thinking it might need that.

Hall sensor wiring
https://randomnerdtutorials.com/esp32-adc-analog-read-arduino-ide/

Plus
https://nathanmelenbrink.github.io/ps70/06_input/index.html
Nathan’s orientation of the wiring was correct, the version I was trying from the data sheet was not.

Past student Hall sensor work:
https://2048-student.github.io/PHYS_S-12/pages/classvii.html

Using this student’s code, the sensor acted more as a touch sensor.

Instead I looked at the calibration week project of this former student:
https://mohammed-mutaher.github.io/PHYSCI-70/06/index6.html

After looking at their setup, I added a 1 Ohm resistor
And used their code instead 

It appears that using this there are rapid peaks and valleys, the peaks with a 1 and 3 ohm resistor go up slightly as one side of the magnet gets close to them, I saw less noticeable change doing that with the 10 ohm resistor. However, this setup will work for me because all I need is for the sensor to know when a magnet is present. If the magnet is flipped over, the sensor reads nothing. If I can get my final project code to run the motor 180 deg in 1 direction, then 360 deg in the other and stop when 2 readings in a row are zero, this version of the sensor should work.

In my very quick rough calibration using ~4mm pieces of cardboard, it seems that the magnet stops being registered by the sensor when it is between 8 and 12 mm away, which is consistent with the upper registers of its sensitivity when it works properly in Nathan and Mohammed’s examples. I decided not to use a resistor, because I felt that was an unnecessary component given what I will be using this setup for.

The next day when I tried this again, it did not work. I switched to limit switches.
_____________________

This is the ReadMe for the GitHub to use the new microphones: https://github.com/maspetsberger/esp32-i2s-mems/blob/master/Readme.md


This is also says how to wire the i2s microphones 

Okay. This was a doozy. It uses functions that don’t exist in the library any more. I could get the code to work with Nathan’s modification in my arduino window: 
<div style="height: 350px; overflow: scroll">
<pre><code class="language-arduino">

/**

 * ESP32 I2S Serial Plotter Example.

*

 * This example is based on the espressif-idf example and Public Domain.

* @author maspetsberger

 */

 

#include <driver/i2s.h>

 

const i2s_port_t I2S_PORT = I2S_NUM_0;

 

void setup() {

  Serial.begin(115200);

  Serial.println("Configuring I2S...");

  esp_err_t err;

 

  // The I2S config as per the example

  const i2s_config_t i2s_config = {

      .mode = i2s_mode_t(I2S_MODE_MASTER | I2S_MODE_RX), // Receive, not transfer

      .sample_rate = 16000,                         // 16KHz

      .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT, // could only get it to work with 32bits

      .channel_format = I2S_CHANNEL_FMT_ONLY_RIGHT, // although the SEL config should be left, it seems to transmit on right

      .communication_format = i2s_comm_format_t(I2S_COMM_FORMAT_STAND_I2S),

      .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,     // Interrupt level 1

      .dma_buf_count = 4,                           // number of buffers

      .dma_buf_len = 8                              // 8 samples per buffer (minimum)

  };

 

  // The pin config as per the setup

  const i2s_pin_config_t pin_config = {

      .bck_io_num = 14,   // BCKL

      .ws_io_num = 15,    // LRCL

      .data_out_num = -1, // not used (only for speakers)

      .data_in_num = 32   // DOUT

  };

 

  // Configuring the I2S driver and pins.

  // This function must be called before any I2S driver read/write operations.

  err = i2s_driver_install(I2S_PORT, &i2s_config, 0, NULL);

  if (err != ESP_OK) {

    Serial.printf("Failed installing driver: %d\n", err);

    while (true);

  }

  err = i2s_set_pin(I2S_PORT, &pin_config);

  if (err != ESP_OK) {

    Serial.printf("Failed setting pin: %d\n", err);

    while (true);

  }

  Serial.println("I2S driver installed.");

}

 

void loop() {

 

  // Read a single sample and log it for the Serial Plotter.

  int32_t sample = 0;

  size_t bytes_read;

  esp_err_t result = i2s_read(I2S_PORT, (char *)&sample, sizeof(sample), &bytes_read, portMAX_DELAY); // no timeout

  if (bytes_read > 0) {

    Serial.println(sample);

  }

 

}


 </code></pre>
  </div>

When trying to get the GetNoiseLevel function to work, that was a challenge. It did not work.

The problem with the samples that I got from the Input Serial Plotter, is that it is recording everything correctly relatively, but thinks that the noise of a room is a low negative number, but when I speak into it it does respond.


Then I made the changes because I realized the Volume Measure thing is what I wanted

My friend Mark thing help change the function so that it read everything as arrays instead of going back and forth in dealing with the sample/samples data

PK help me make the classes in this volume setup. This was in the final code in the other documentation page.

__________________________

Only 2 i2s ports channels on ESP32 aka need to redesign or figure out how read right and left channels on each of those ports, I think I will do 2 microphones instead of 3!
https://docs.espressif.com/projects/esp-idf/en/release-v4.2/esp32/api-reference/peripherals/i2s.html

I later learned these are not physical ports but configurable channels. Because later that day it did not work with three microphones when I had just added them to the microphone-specific stuff, not this bit: const i2s_port_t I2S_PORT = I2S_NUM_0; at the beginning.

When kassia added that the code should call 0, 1, and 2 (for each microphone) turns out 2 doesn’t exist. It seems like, based off a little googling, there should be a way for the esp32 to be able to read 4 microphones of each channel of these ports, I have not been able to find easily accessible code for that, so I am going to adapt my project to only use two microphones to decide where to point.
Other things kassia did to the code:
Added the calling ports to the functions for each microphone
Made a “failed to install driver” message for each port
Serial prints to confirm each mic is starting

________________________
My hall effect sensor stopped working and I moved to a limit switch

GET HELP WITH HALL EFFECT SENSOR AND STOPPING/CALIBRATING THE MOTOR

This is what I think I should write for my code in settinguphallsensor.ino
I used this video: https://www.youtube.com/watch?v=bOfizJBpMrA
For counter help

Actually nevermind. I do not know how the hall sensor will work, therefore I cannot do this

I am going to use a limit switch instead and put it on the top of my project base so that the turning top slider will trigger it!

https://arduinogetstarted.com/tutorials/arduino-limit-switch
^ training tutorial I used to learn how to use a limit switch

What if i constantly had the motors take ratio measurements and only move if the ratio was greater than a certain amount? Then the motor wouldn’t freak out as the person speaking moves just a little bit. Then if the ration x stepnumberbetween microphones is less that what it was it will take steps backwards if the new ratio is greater it will go forwards.
________________________

LIMIT SWITCH doesn’t work
Why
Try soldering then cry
Make into a class first

EVERYTHING FITS!! FOR 3D PRINT! EXCEPT little posts for the microcontroller did not work, but that’s ok I just popped them out so nothing would potentially get in the way later

And the limit switch will just barely click when the thing goes over it, the switch pops back up, so it will always have to do one full rotation before it starts:

Turn 360 deg counter clockwise until (for limit switch = UNTOUCHED until limit switch = TOUCHED turn 360 counterclockwise)
When limit switch = Touched then turn ¼ (800 microsteps) of the way more in the cc direction, set steps taken = zero
^ setup

Pseudocode Draft:

Check microphones
Save that ratio as a variable

Move to sound
At end of move to sound, save that ratio variable as LastMoveRatio


If Ratio >= LastMoveRatio +- 1/10th 
Move to sound


Move to Sound;

If mic 2> mic 1 then move counterclockwise
If mic 2 , mic 1 then move clockwise 


Multiply ratio by 1600
_________

Next thing to do:
Wire in the limit switch, see if its a connection issue
Wire in mics and test the calibration stuff on them, glue things into place until someone can help you 
Calculate the separated ratios


According to my initial calibration and so, the first iteration of my code, the ratio changed greater than a hundredth between most of the distinct angles I calibrated for. 

Shortsights with the project as a whole: It makes louder people louder, if they are louder than the room around them then the mic will face them more than the quieter person who is relatively less loud compared to the room sound being picked up by the other microphone

Will have to tangle its own cord a little because of switch instead of hall or motion sensor

__________________

Snatched this man’s code to test stepper motor classing:
https://www.dropbox.com/sh/ya76wwmwtvk4cgi/AADbrXeYzaF81sZp3TY_TRkQa?dl=0

Everything else was put into the final documentation page!












</xmp>
</body>

<script src="./strapdown.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" ></script>

</html>